#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

// Определяем частоту процессора для корректной работы _delay_ms()
#define F_CPU 8000000UL

// Рассчитанное значение для регистра сравнения (для 40 мс с предделителем 64)
// (F_CPU / PRESCALER * 0.040) - 1 = (8000000 / 64 * 0.040) - 1 = 5000 - 1 = 4999
#define COMPARE_VALUE 4999

// Флаг для отслеживания состояния таймера (1 - работает, 0 - остановлен)
volatile uint8_t is_timer_running = 1;

// Обработчик прерывания по СОВПАДЕНИЮ с OCR1A (режим CTC)
ISR(TIMER1_COMPA_vect)
{
    // Теперь не нужно перезагружать счетчик TCNT1, он сбрасывается аппаратно в 0.
    
    // Просто инвертируем состояние светодиода на PB0
    PORTB ^= (1 << PB0); 
}

int main(void)
{
    // --- Настройка портов ---
    // Настраиваем PB0 как выход (для светодиода)
    DDRB |= (1 << DDB0);
    
    // Настраиваем PD4 как вход (для кнопки)
    DDRD &= ~(1 << DDD4);
    // Включаем внутренний подтягивающий резистор для PD4
    PORTD |= (1 << PORTD4);
    
    // --- Настройка Timer1 в режиме CTC ---
    
    // 1. Устанавливаем режим работы CTC (WGM12 = 1). TCCR1A оставляем по нулям.
    TCCR1B |= (1 << WGM12);
    
    // 2. Записываем рассчитанное значение в регистр сравнения OCR1A.
    // Компилятор сам правильно разделит это 16-битное число
    // на два 8-битных регистра OCR1AH и OCR1AL.
    OCR1A = COMPARE_VALUE;
    
    // 3. Разрешаем прерывание по совпадению с OCR1A (OCIE1A).
    TIMSK |= (1 << OCIE1A);
    
    // --- Первоначальный запуск таймера ---
    
    // 4. Устанавливаем предделитель 64 (CS11=1, CS10=1) для запуска таймера.
    TCCR1B |= (1 << CS11) | (1 << CS10);
    is_timer_running = 1; // Устанавливаем флаг, что таймер запущен
    
    // Глобально разрешаем все прерывания
    sei();

    // Основной бесконечный цикл для опроса кнопки
    while (1) 
    {
        // Проверяем, нажата ли кнопка на PD4 (логический 0 при нажатии)
        if (!(PIND & (1 << PD4)))
        {
            // Устранение дребезга контактов
            _delay_ms(50); 
            
            if (is_timer_running) // Если таймер работал
            {
                // Останавливаем таймер, сбрасывая биты предделителя
                TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
                is_timer_running = 0; // Обновляем флаг
            }
            else // Если таймер был остановлен
            {
                // Запускаем таймер, устанавливая предделитель 64
                TCCR1B |= (1 << CS11) | (1 << CS10);
                is_timer_running = 1; // Обновляем флаг
            }
            
            // Ждем, пока кнопка будет отпущена, чтобы избежать многократного срабатывания
            while(!(PIND & (1 << PD4)));
        }
    }
    
    return 0; // Эта строка никогда не выполнится
}
